<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>é€†å¤©æŒ‚æœºï¼šä¸€å‰‘é£å‡</title>
  <style>
    body {
      font-family: 'Microsoft YaHei', sans-serif;
      background: linear-gradient(to bottom, #0a0e2a, #1a1a4a);
      color: #e6e6e6;
      margin: 0;
      padding: 20px;
      background-attachment: fixed;
    }
    .container {
      max-width: 1000px;
      margin: auto;
      display: flex;
      gap: 20px;
    }
    .main-panel {
      flex: 3;
    }
    .sidebar {
      flex: 2;
      background: rgba(10, 20, 50, 0.7);
      padding: 15px;
      border-radius: 12px;
      backdrop-filter: blur(5px);
      border: 1px solid #3a50a0;
    }
    h1 {
      text-align: center;
      color: #ff5c8d;
      text-shadow: 0 0 10px #ff5c8d;
      font-size: 2em;
    }
    .stats {
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 15px;
      line-height: 1.8;
      border-left: 5px solid #5ce6e6;
    }
    .log {
      height: 300px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.3);
      padding: 12px;
      border-radius: 8px;
      font-size: 14px;
      border: 1px solid #2a4a8a;
    }
    .log div {
      margin-bottom: 6px;
    }
    .inventory {
      margin-top: 15px;
    }
    .equipment-item {
      padding: 8px;
      margin-top: 5px;
      background: rgba(30, 30, 60, 0.6);
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .equipment-item:hover {
      background: rgba(60, 60, 100, 0.8);
      transform: translateX(5px);
    }
    .btn {
      background: #ff5c8d;
      color: white;
      border: none;
      padding: 8px 12px;
      margin: 5px 2px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }
    .btn:hover { background: #ff8ca8; }
    .btn-big {
      background: #d4af37;
      padding: 12px;
      font-size: 16px;
      width: 100%;
    }
    .grade-0 { color: #aaa; }
    .grade-1 { color: white; }
    .grade-2 { color: #32cd32; }
    .grade-3 { color: #1e90ff; }
    .grade-4 { color: #9932cc; }
    .grade-5 { color: #ff8c00; }
    .grade-6 { color: #d4af37; }

    /* æˆå°± */
    .achievement {
      padding: 6px;
      margin: 4px 0;
      background: rgba(100, 50, 150, 0.3);
      border-radius: 4px;
      font-size: 12px;
    }
    .achieved {
      background: rgba(50, 200, 100, 0.3);
      color: #8fff8f;
    }
  </style>
</head>
<body>

  <h1>ğŸŒŒ é€†å¤©æŒ‚æœºï¼šä¸€å‰‘é£å‡</h1>

  <div class="container">
    <div class="main-panel">
      <div class="stats" id="playerStats">åŠ è½½ä¸­...</div>
      <div class="log" id="combatLog"></div>
    </div>

    <div class="sidebar">
      <h3>ğŸ’ èƒŒåŒ… (<span id="invCount">0</span>/50)</h3>
      <div>
        <label><input type="checkbox" id="autoPickup" checked> è‡ªåŠ¨æ‹¾å–</label>
        <select id="minGradeForPickup">
          <option value="0">ä¸å±è”½</option>
          <option value="1">æ™®é€šåŠä»¥ä¸Š</option>
          <option value="2">ç²¾è‰¯åŠä»¥ä¸Š</option>
          <option value="3">ç¨€æœ‰åŠä»¥ä¸Š</option>
          <option value="4">å²è¯—åŠä»¥ä¸Š</option>
          <option value="5">ç¥è¯åŠä»¥ä¸Š</option>
        </select>
      </div>
      <button onclick="discardAll()" class="btn">ğŸ—‘ï¸ ä¸¢å¼ƒå…¨éƒ¨</button>
      <button onclick="sellAll()" class="btn">ğŸ’° å‡ºå”®åƒåœ¾</button>

      <h3>ğŸ¯ å½“å‰å‰¯æœ¬</h3>
      <select id="dungeonSelect" onchange="changeDungeon()"></select>
      <div id="dungeonInfo"></div>

      <h3>âš”ï¸ è£…å¤‡æ </h3>
      <div id="equipslot"></div>

      <h3>ğŸ† æˆå°±</h3>
      <div id="achievements"></div>

      <h3>âš¡ æ¸¡åŠ«å°</h3>
      <button id="btnTrib" class="btn btn-big" onclick="attemptTribulation()" style="display:none;">
        ğŸ”¥ æ¸¡åŠ«çªç ´ï¼å¤©é›·æ»šæ»šè€Œæ¥ï¼
      </button>
    </div>
  </div>

  <script>
    // ==================== æ•°æ®å®šä¹‰ ====================
    const REALMS = ["ç‚¼æ°”æœŸ", "ç­‘åŸºæœŸ", "é‡‘ä¸¹æœŸ", "å…ƒå©´æœŸ", "åŒ–ç¥æœŸ", "åˆä½“æœŸ", "å¤§ä¹˜æœŸ", "æ¸¡åŠ«æœŸ"];
    const DUNGEONS = [
      { name: "å‡¡äººæ´ç©´", monster: "é‡çŒªå¦–|æ¯’è›‡æ€ª|å°é¬¼", dropBase: 1, bossChance: 0.05 },
      { name: "å¹½å†¥å¤å¢“", monster: "éª·é«…å…µ|å¹½é­‚|çŸ³åƒé¬¼", dropBase: 3, bossChance: 0.1 },
      { name: "ä¹å¹½é­”åŸŸ", monster: "ç‚é­”|å½±åˆºå®¢|è¡€å‚€å„¡", dropBase: 6, bossChance: 0.15 },
      { name: "æ··æ²Œç¦åŒº", monster: "è™šç©ºå…½|å •ç¥æ®‹å¿µ|æ··æ²Œé­”", dropBase: 10, bossChance: 0.2 }
    ];
    const GRADES = ["ç ´æŸ", "æ™®é€š", "ç²¾è‰¯", "ç¨€æœ‰", "å²è¯—", "ç¥è¯", "ä¼ è¯´"];
    const GRADE_MULTIPLIERS = [0.5, 1.0, 1.8, 2.8, 4.0, 6.0, 10.0];
    const GRADE_EXTRA_ATTR_RANGE = [[0,1], [1,1], [2,2], [2,3], [3,4], [4,5], [5,6]];

    const EXTRA_ATTRS = [
      { n: "ç”Ÿå‘½å€¼", min: 10, max: 50 },
      { n: "æš´å‡»ç‡(%)", min: 1.0, max: 5.0, f: true },
      { n: "æ”»å‡»é€Ÿåº¦", min: 1, max: 5 },
      { n: "é—ªé¿ç‡(%)", min: 1.0, max: 5.0, f: true },
      { n: "å¸è¡€ç‡(%)", min: 0.5, max: 3.0, f: true },
      { n: "ç ´ç”²ç‡(%)", min: 1.0, max: 4.0, f: true },
      { n: "çœŸä¼¤åŠ æˆ", min: 5, max: 15 }
    ];

    const EQUIP_SLOTS = ["æ­¦å™¨", "æŠ¤ç”²", "å¤´å† ", "æŠ¤è…¿", "é¥°å“"];

    // æˆå°±åˆ—è¡¨
    const ACHIEVEMENTS = [
      { id: "kill_10", cond: (p) => p.killCount >= 10, name: "åˆå…¥æ±Ÿæ¹–", desc: "å‡»æ€10ä¸ªæ€ªç‰©" },
      { id: "kill_100", cond: (p) => p.killCount >= 100, name: "æ€æˆ®æˆæ€§", desc: "å‡»æ€100ä¸ªæ€ªç‰©" },
      { id: "mythical", cond: (p) => p.stats.hasMythical, name: "ç¥è¯é™ä¸´", desc: "è·å¾—ä¸€ä»¶ç¥è¯è£…å¤‡" },
      { id: "legend", cond: (p) => p.stats.hasLegend, name: "ä¸‡å¤å”¯ä¸€", desc: "è·å¾—ä¼ è¯´æ³•å®" },
      { id: "realm_4", cond: (p) => p.realm >= 4, name: "åŒ–ç¥å°Šè€…", desc: "çªç ´è‡³åŒ–ç¥æœŸ" },
      { id: "gold_1000", cond: (p) => p.gold >= 1000, name: "å¯Œå¯æ•Œå›½", desc: "æ‹¥æœ‰1000çµçŸ³" }
    ];

    // ç©å®¶æ•°æ®
    const player = {
      level: 1,
      realm: 0,
      attack: 10,
      defense: 5,
      health: 100,
      killCount: 0,
      dungeon: 0,
      inventory: [],
      equipment: {},
      skills: [],
      gold: 0,
      lastSave: Date.now(),
      achievements: {}, // å·²è§£é”æˆå°±
      stats: { hasMythical: false, hasLegend: false }, // ç»Ÿè®¡
      inTribulation: false
    };

    for (let slot of EQUIP_SLOTS) player.equipment[slot] = null;
    for (let ach of ACHIEVEMENTS) player.achievements[ach.id] = false;

    // ==================== å·¥å…·å‡½æ•° ====================
    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function randFloat(min, max) {
      return parseFloat((Math.random() * (max - min) + min).toFixed(1));
    }
    function roll(prob) { return Math.random() < prob; }
    function log(text, cls = "") {
      const logDiv = document.getElementById("combatLog");
      const entry = document.createElement("div");
      if (cls) entry.className = cls;
      entry.textContent = `[${formatTime()}] ${text}`;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
    }
    function formatTime() {
      const d = new Date();
      return `${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}`;
    }

    // ==================== ç”Ÿæˆè£…å¤‡ ====================
    function createEquipment(dungeonLevel) {
      let gradeIndex = dungeonLevel + randInt(-1, 2);
      gradeIndex = Math.max(0, Math.min(6, gradeIndex));
      if (window._isBoss) gradeIndex = Math.min(6, gradeIndex + 1);

      const multiplier = GRADE_MULTIPLIERS[gradeIndex] * (1 + dungeonLevel * 0.3);
      const type = EQUIP_SLOTS[randInt(0, 4)];
      const prefix = ["æ— å", "é’é”‹", "èµ¤ç„°", "ç„å†°", "é›·éœ†", "æ˜Ÿè¾°", "æ··æ²Œ"][randInt(0, 6)];

      const equip = {
        id: Date.now() + randInt(1, 1000),
        grade: GRADES[gradeIndex],
        gradeIndex: gradeIndex,
        type: type,
        name: `${prefix}Â·${type}`,
        baseAttributes: {},
        extraAttributes: {}
      };

      const baseAttack = Math.round(5 * multiplier * (0.8 + Math.random() * 0.4));
      const baseDefense = Math.round(3 * multiplier * (0.8 + Math.random() * 0.4));
      if (type === "æ­¦å™¨") equip.baseAttributes["æ”»å‡»åŠ›"] = baseAttack;
      else equip.baseAttributes["é˜²å¾¡åŠ›"] = baseDefense;

      const [minE, maxE] = GRADE_EXTRA_ATTR_RANGE[gradeIndex];
      const numExtra = randInt(minE, maxE);
      const attrsPool = [...EXTRA_ATTRS];
      for (let i = 0; i < numExtra && attrsPool.length > 0; i++) {
        const idx = randInt(0, attrsPool.length - 1);
        const attr = attrsPool.splice(idx, 1)[0];
        const value = attr.f ? randFloat(attr.min, attr.max) : randInt(attr.min, attr.max);
        equip.extraAttributes[attr.n] = value;
      }

      if (gradeIndex === 6) {
        const effects = ["å¯¹BOSSä¼¤å®³+15%", "å‡»æ€å›è¡€5%", "æ‰è½ç‡+20%", "ç»éªŒ+30%"];
        equip.effect = effects[randInt(0, effects.length - 1)];
      }

      return equip;
    }

    // ==================== æˆ˜æ–— ====================
    function fight() {
      if (player.inTribulation) return;
      const dungeon = DUNGEONS[player.dungeon];
      const names = dungeon.monster.split("|");
      let name = names[randInt(0, names.length - 1)];
      const isBoss = roll(dungeon.bossChance);
      const isElite = roll(0.15);

      if (isBoss) name = `ã€å¤©åŠ«${name}Â·BOSSã€‘`;
      else if (isElite) name = `ã€æš—å½±${name}Â·ç²¾è‹±ã€‘`;

      log(`ğŸŒ€ é­é‡ ${name}ï¼`);

      setTimeout(() => {
        log(`âœ… é•‡å‹ ${name}ï¼`, "success");
        player.killCount++;

        checkAchievements();

        window._isBoss = isBoss || isElite;
        if (roll(0.7)) {
          const equipment = createEquipment(player.dungeon);
          if (equipment.gradeIndex >= 5) player.stats.hasMythical = true;
          if (equipment.gradeIndex >= 6) player.stats.hasLegend = true;
          autoPickOrDrop(equipment);
        } else {
          const gold = randInt(1, 5) * (player.dungeon + 1);
          player.gold += gold;
          log(`ğŸ’° ç¼´è·çµçŸ³ Ã—${gold}`);
        }

        checkRealmAdvance();
        updateUI();
      }, 600);
    }

    // ==================== å¢ƒç•Œçªç ´åˆ¤å®š ====================
    function checkRealmAdvance() {
      const thresholds = [10, 30, 60, 100, 150, 210, 280]; // æ¯å±‚æ‰€éœ€å‡»æ€
      if (player.realm < thresholds.length && player.killCount >= thresholds[player.realm]) {
        player.inTribulation = true;
        log("âš¡ å¤©é“æ„Ÿåº”ï¼ä½ å·²è¾¾åˆ°ç“¶é¢ˆï¼Œå¯å°è¯•æ¸¡åŠ«çªç ´ï¼", "upgrade");
        document.getElementById("btnTrib").style.display = "block";
      }
    }

    function attemptTribulation() {
      const successRate = 0.7 + player.realm * 0.05;
      log(`ğŸ”¥ æ¸¡åŠ«å¼€å§‹ï¼æˆåŠŸç‡çº¦ ${(successRate*100).toFixed(0)}%...`);
      setTimeout(() => {
        if (roll(successRate)) {
          player.realm++;
          log(`ğŸ’¥ æˆåŠŸæ¸¡åŠ«ï¼è¿›å…¥ã€${REALMS[player.realm]}ã€‘ï¼`, "upgrade");
          document.getElementById("btnTrib").style.display = "none";
          player.inTribulation = false;
          applyEquipStats();
          unlockSkill();
        } else {
          const loss = Math.floor(player.killCount * 0.1);
          player.killCount = Math.max(1, player.killCount - loss);
          log(`âŒ æ¸¡åŠ«å¤±è´¥ï¼ä¿®ä¸ºå—æŸï¼Œæ€æˆ®æ•°-${loss}`, "fail");
        }
        updateUI();
      }, 1500);
    }

    // ==================== èƒŒåŒ… & æ‹¾å– ====================
    function autoPickOrDrop(equip) {
      const minGrade = parseInt(document.getElementById("minGradeForPickup").value);
      const autoPick = document.getElementById("autoPickup").checked;

      if (autoPick && equip.gradeIndex < minGrade) {
        log(`ğŸ—‘ï¸ è‡ªåŠ¨ä¸¢å¼ƒã€${equip.grade}ã€‘${equip.name}`);
        return;
      }

      if (player.inventory.length >= 50) {
        log("ğŸ’ èƒŒåŒ…å·²æ»¡ï¼");
        return;
      }

      player.inventory.push(equip);
      log(`ğŸ è·å¾—æ³•å®ï¼šã€${equip.grade}ã€‘${equip.name}`, `grade-${equip.gradeIndex}`);
    }

    function discardAll() {
      const count = player.inventory.length;
      player.inventory = [];
      log(`ğŸ—‘ï¸ æ— æƒ…ä¸¢å¼ƒ ${count} ä»¶æ³•å®ï¼å¤§é“æ— æƒ…ï¼`);
      updateUI();
    }

    function sellAll() {
      const minSell = parseInt(prompt("å‡ºå”®ä½äºå“ªä¸ªå“è´¨ï¼Ÿ0=ç ´æŸ,1=æ™®é€š...", "1")) || 1;
      const filtered = player.inventory.filter(eq => eq.gradeIndex < minSell);
      const gold = filtered.reduce((sum, eq) => sum + (eq.gradeIndex + 1) * 10, 0);
      player.gold += gold;
      player.inventory = player.inventory.filter(eq => eq.gradeIndex >= minSell);
      log(`ğŸ’° å‡ºå”® ${filtered.length} ä»¶æ³•å®ï¼Œè·å¾—çµçŸ³ Ã—${gold}`);
      updateUI();
    }

    // ==================== è£…å¤‡ç³»ç»Ÿ ====================
    function equipItem(id) {
      const item = player.inventory.find(eq => eq.id === id);
      if (!item) return;
      const old = player.equipment[item.type];
      if (old) player.inventory.push(old);
      player.equipment[item.type] = item;
      player.inventory = player.inventory.filter(eq => eq.id !== id);
      applyEquipStats();
      log(`âš”ï¸ è£…å¤‡æ³•å®ï¼š${item.name}`);
      updateUI();
    }

    function unequip(slot) {
      const item = player.equipment[slot];
      if (item) {
        player.inventory.push(item);
        player.equipment[slot] = null;
        applyEquipStats();
        log(`ğŸ§¼ å¸ä¸‹æ³•å®ï¼š${item.name}`);
        updateUI();
      }
    }

    function applyEquipStats() {
      let atkBonus = 0, defBonus = 0;
      for (const slot in player.equipment) {
        const eq = player.equipment[slot];
        if (!eq) continue;
        if (eq.baseAttributes["æ”»å‡»åŠ›"]) atkBonus += eq.baseAttributes["æ”»å‡»åŠ›"];
        if (eq.baseAttributes["é˜²å¾¡åŠ›"]) defBonus += eq.baseAttributes["é˜²å¾¡åŠ›"];
      }
      player.attack = 10 + atkBonus + player.realm * 5;
      player.defense = 5 + defBonus + player.realm * 2;
    }

    // ==================== æˆå°±ç³»ç»Ÿ ====================
    function checkAchievements() {
      let newAch = 0;
      ACHIEVEMENTS.forEach(ach => {
        if (!player.achievements[ach.id] && ach.cond(player)) {
          player.achievements[ach.id] = true;
          log(`ğŸ† è§£é”æˆå°±ï¼šã€${ach.name}ã€‘â€”â€” ${ach.desc}`, "success");
          newAch++;
        }
      });
      if (newAch > 0) updateAchievements();
    }

    function updateAchievements() {
      const div = document.getElementById("achievements");
      div.innerHTML = "";
      ACHIEVEMENTS.forEach(ach => {
        const item = document.createElement("div");
        item.className = `achievement ${player.achievements[ach.id] ? 'achieved' : ''}`;
        item.textContent = `${ach.name}ï¼š${ach.desc}`;
        div.appendChild(item);
      });
    }

    // ==================== å­˜æ¡£ ====================
    function saveGame() {
      try {
        localStorage.setItem("immortal_idle_save", JSON.stringify(player));
        player.lastSave = Date.now();
      } catch (e) {
        console.error("å­˜æ¡£å¤±è´¥", e);
      }
    }

    function loadGame() {
      const save = localStorage.getItem("immortal_idle_save");
      if (save) {
        try {
          const data = JSON.parse(save);
          Object.assign(player, data);
          log("ğŸ“œ æ£€æµ‹åˆ°å¾€ç”Ÿè®°å¿†ï¼Œå·²åŠ è½½...");
        } catch (e) {
          console.error(e);
        }
      } else {
        log("âœ¨ æ–°ç”Ÿé“å‹ï¼Œè¸ä¸Šé€†å¤©ä¹‹è·¯ï¼");
      }
    }

    // ==================== UI æ›´æ–° ====================
    function updateUI() {
      updatePlayerStats();
      updateInventory();
      updateDungeonSelect();
      updateDungeonInfo();
      updateEquipSlot();
      updateAchievements();
      document.getElementById("btnTrib").style.display = player.inTribulation ? "block" : "none";
    }

    function updatePlayerStats() {
      document.getElementById("playerStats").innerHTML = `
        <strong>é“å·</strong>: æ— åé“å‹<br/>
        <strong>å¢ƒç•Œ</strong>: ã€${REALMS[player.realm]}ã€‘${player.inTribulation ? ' âš ï¸å¾…æ¸¡åŠ«' : ''}<br/>
        <strong>æ”»å‡»åŠ›</strong>: ${player.attack} | <strong>é˜²å¾¡åŠ›</strong>: ${player.defense}<br/>
        <strong>çµçŸ³</strong>: ${player.gold} | <strong>æ€æˆ®æ•°</strong>: ${player.killCount}
      `;
    }

    function updateInventory() {
      const inv = document.getElementById("inventory");
      const countSpan = document.getElementById("invCount");
      countSpan.textContent = player.inventory.length;

      inv.innerHTML = "";
      if (player.inventory.length === 0) {
        inv.innerHTML = "<p style='opacity:0.6'>èº«å¤–æ— ç‰©ï¼Œæ–¹å¾—è‡ªåœ¨</p>";
        return;
      }

      player.inventory.slice(-8).reverse().forEach(eq => {
        const div = document.createElement("div");
        div.className = `equipment-item grade-${eq.gradeIndex}`;
        div.innerHTML = `
          ${eq.name} 
          <span style="float:right;">
            <button onclick="equipItem(${eq.id})">è£…å¤‡</button>
          </span>
        `;
        div.onclick = () => equipItem(eq.id);
        inv.appendChild(div);
      });
    }

    function updateDungeonSelect() {
      const sel = document.getElementById("dungeonSelect");
      sel.innerHTML = "";
      DUNGEONS.forEach((d, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.text = d.name;
        if (i === player.dungeon) opt.selected = true;
        sel.appendChild(opt);
      });
    }

    function changeDungeon() {
      player.dungeon = parseInt(document.getElementById("dungeonSelect").value);
      log(`ğŸšª åˆ‡æ¢å‰¯æœ¬ï¼š${DUNGEONS[player.dungeon].name}`);
      updateDungeonInfo();
    }

    function updateDungeonInfo() {
      const d = DUNGEONS[player.dungeon];
      document.getElementById("dungeonInfo").innerHTML = `
        éš¾åº¦ï¼š${d.dropBase}å€æ‰è½<br/>
        BOSSæ¦‚ç‡ï¼š${(d.bossChance*100).toFixed(1)}%
      `;
    }

    function updateEquipSlot() {
      const div = document.getElementById("equipslot");
      div.innerHTML = "";
      for (const slot in player.equipment) {
        const eq = player.equipment[slot];
        const item = document.createElement("div");
        item.style.margin = "5px 0";
        if (eq) {
          item.innerHTML = `${slot}ï¼š${eq.name} <button onclick="unequip('${slot}')">å¸ä¸‹</button>`;
          item.className = `grade-${eq.gradeIndex}`;
        } else {
          item.innerHTML = `${slot}ï¼šç©º`;
          item.style.opacity = 0.5;
        }
        div.appendChild(item);
      }
    }

    function unlockSkill() {
      if (player.realm === 1) log("ğŸ§  è§£é”æŠ€èƒ½ï¼šã€çœŸæ°”æŠ¤ä½“ã€‘ï¼");
      if (player.realm === 4) log("ğŸ’¥ è§£é”ç¥é€šï¼šã€ä¸‡å‰‘å½’å®—ã€‘ï¼");
    }

    // ==================== åˆå§‹åŒ– ====================
    window.onload = () => {
      loadGame();
      updateUI();
      fight();
      setInterval(fight, 3000);
      setInterval(saveGame, 60000);
    };
  </script>
</body>
</html>
